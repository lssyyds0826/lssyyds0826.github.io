<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MPCæ™ºèƒ½æ§åˆ¶ - æ–‡åŒ–é—äº§æœºå™¨äºº</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Microsoft YaHei', sans-serif; 
            background: #1a1a2e;
            color: white;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }
        
        /* ä¸»åœºæ™¯ */
        #scene-container {
            flex: 3;
            position: relative;
            background: #0f3460;
        }
        
        canvas {
            display: block;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        #control-panel {
            flex: 1;
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 25px;
            max-width: 450px;
            overflow-y: auto;
            border-left: 4px solid #00b4d8;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
        }
        
        /* MPCæ§åˆ¶åŒº */
        .mpc-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(0, 180, 216, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .mpc-section h3 {
            color: #00b4d8;
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .mpc-section h3::before {
            content: "ğŸ¤–";
            font-size: 1.5rem;
        }
        
        /* æ§åˆ¶æŒ‰é’® */
        .mpc-btn {
            width: 100%;
            padding: 16px;
            margin: 10px 0;
            background: linear-gradient(135deg, #0077b6, #0096c7);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        
        .mpc-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 150, 199, 0.4);
            background: linear-gradient(135deg, #0096c7, #00b4d8);
        }
        
        .mpc-btn:active {
            transform: translateY(-1px);
        }
        
        .mpc-btn.avoid {
            background: linear-gradient(135deg, #ff9e00, #ffaa00);
        }
        
        .mpc-btn.pickup {
            background: linear-gradient(135deg, #2a9d8f, #2a9d8f);
        }
        
        /* é¢„æµ‹è½¨è¿¹å¯è§†åŒ– */
        .prediction-viz {
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }
        
        .prediction-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, #00b4d8, #90e0ef);
            border-radius: 3px;
            transform-origin: left center;
        }
        
        /* ä¿¡æ¯é¢æ¿ */
        .info-panel {
            background: rgba(229, 56, 59, 0.1);
            border-left: 4px solid #e5383b;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            color: #e0e0e0;
        }
        
        .info-label {
            color: #90e0ef;
        }
        
        .info-value {
            font-weight: bold;
            color: #ffffff;
        }
        
        /* MPCæ­¥éª¤å±•ç¤º */
        .step-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .step {
            background: rgba(0, 180, 216, 0.1);
            border: 2px solid rgba(0, 180, 216, 0.3);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .step.active {
            background: rgba(0, 180, 216, 0.3);
            border-color: #00b4d8;
            transform: scale(1.05);
        }
        
        .step-number {
            font-size: 1.2rem;
            font-weight: bold;
            color: #00b4d8;
            margin-bottom: 5px;
        }
        
        /* æ—¥å¿—è¾“å‡º */
        .mpc-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin: 5px 0;
            padding-left: 10px;
            border-left: 2px solid #00b4d8;
        }
        
        .log-time {
            color: #90e0ef;
        }
        
        .log-message {
            color: #e0e0e0;
        }
        
        /* æ€§èƒ½æŒ‡æ ‡ */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 15px 0;
        }
        
        .metric {
            background: rgba(42, 157, 143, 0.1);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2a9d8f;
            margin: 5px 0;
        }
        
        .metric-label {
            font-size: 0.9rem;
            color: #90e0ef;
        }
    </style>
</head>
<body>
    <!-- 3Dåœºæ™¯å®¹å™¨ -->
    <div id="scene-container"></div>
    
    <!-- MPCæ§åˆ¶é¢æ¿ -->
    <div id="control-panel">
        <div style="margin-bottom: 25px;">
            <h1 style="color: #00b4d8; font-size: 1.8rem; margin-bottom: 8px;">ğŸ§  MPCæ™ºèƒ½æ§åˆ¶ç³»ç»Ÿ</h1>
            <p style="color: #90e0ef; font-size: 0.95rem;">æ–‡åŒ–é—äº§ä¿æŠ¤ - æ¨¡å‹é¢„æµ‹æ§åˆ¶æ¼”ç¤º</p>
        </div>
        
        <!-- MPCæ ¸å¿ƒæ§åˆ¶åŒº -->
        <div class="mpc-section">
            <h3>ğŸš€ MPCä»»åŠ¡æ‰§è¡Œ</h3>
            <button class="mpc-btn" onclick="executeMPC('path')">
                <span style="font-size: 1.2rem;">ğŸ“</span> æœ€ä¼˜è·¯å¾„è§„åˆ’
            </button>
            <button class="mpc-btn avoid" onclick="executeMPC('avoid')">
                <span style="font-size: 1.2rem;">ğŸ›¡ï¸</span> æ™ºèƒ½é¿éšœæ¼”ç¤º
            </button>
            <button class="mpc-btn pickup" onclick="executeMPC('pickup')">
                <span style="font-size: 1.2rem;">ğŸ¤–</span> è‡ªåŠ¨æŠ“å–è§„åˆ’
            </button>
            <button class="mpc-btn" onclick="executeMPC('full')" style="background: linear-gradient(135deg, #9d4edd, #7b2cbf);">
                <span style="font-size: 1.2rem;">ğŸ¬</span> å®Œæ•´å·¥ä½œæµç¨‹
            </button>
        </div>
        
        <!-- é¢„æµ‹è½¨è¿¹å¯è§†åŒ– -->
        <div class="mpc-section">
            <h3>ğŸ“Š MPCé¢„æµ‹è½¨è¿¹</h3>
            <div class="prediction-viz" id="predictionViz">
                <!-- é¢„æµ‹è½¨è¿¹ä¼šåŠ¨æ€ç»˜åˆ¶åœ¨è¿™é‡Œ -->
            </div>
            <div class="info-panel">
                <div class="info-item">
                    <span class="info-label">é¢„æµ‹æ­¥é•¿ï¼š</span>
                    <span class="info-value" id="horizonValue">20æ­¥</span>
                </div>
                <div class="info-item">
                    <span class="info-label">ä¼˜åŒ–è¿­ä»£ï¼š</span>
                    <span class="info-value" id="iterationsValue">0æ¬¡</span>
                </div>
                <div class="info-item">
                    <span class="info-label">è®¡ç®—æ—¶é—´ï¼š</span>
                    <span class="info-value" id="computeTime">0ms</span>
                </div>
            </div>
        </div>
        
        <!-- MPCå·¥ä½œæ­¥éª¤ -->
        <div class="mpc-section">
            <h3>âš™ï¸ MPCå·¥ä½œæµç¨‹</h3>
            <div class="step-container">
                <div class="step" id="step1">
                    <div class="step-number">1</div>
                    <div>å»ºç«‹æ¨¡å‹</div>
                </div>
                <div class="step" id="step2">
                    <div class="step-number">2</div>
                    <div>é¢„æµ‹è½¨è¿¹</div>
                </div>
                <div class="step" id="step3">
                    <div class="step-number">3</div>
                    <div>ä¼˜åŒ–æ±‚è§£</div>
                </div>
            </div>
            <div class="step-container">
                <div class="step" id="step4">
                    <div class="step-number">4</div>
                    <div>æ‰§è¡Œæ§åˆ¶</div>
                </div>
                <div class="step" id="step5">
                    <div class="step-number">5</div>
                    <div>åé¦ˆæ›´æ–°</div>
                </div>
                <div class="step" id="step6">
                    <div class="step-number">6</div>
                    <div>å¾ªç¯ä¼˜åŒ–</div>
                </div>
            </div>
        </div>
        
        <!-- æ€§èƒ½æŒ‡æ ‡ -->
        <div class="mpc-section">
            <h3>ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡</h3>
            <div class="metrics-grid">
                <div class="metric">
                    <div class="metric-label">è·¯å¾„é•¿åº¦</div>
                    <div class="metric-value" id="pathLength">0m</div>
                </div>
                <div class="metric">
                    <div class="metric-label">èƒ½é‡æ¶ˆè€—</div>
                    <div class="metric-value" id="energyCost">0J</div>
                </div>
                <div class="metric">
                    <div class="metric-label">é¿éšœè·ç¦»</div>
                    <div class="metric-value" id="obstacleDist">âˆm</div>
                </div>
                <div class="metric">
                    <div class="metric-label">å¹³æ»‘åº¦</div>
                    <div class="metric-value" id="smoothness">100%</div>
                </div>
            </div>
        </div>
        
        <!-- è¿è¡Œæ—¥å¿— -->
        <div class="mpc-section">
            <h3>ğŸ“ MPCè¿è¡Œæ—¥å¿—</h3>
            <div class="mpc-log" id="mpcLog">
                <div class="log-entry">
                    <span class="log-time">[ç³»ç»Ÿå¯åŠ¨]</span>
                    <span class="log-message">MPCæ§åˆ¶ç³»ç»Ÿå·²å°±ç»ª</span>
                </div>
            </div>
        </div>
    </div>

    <!-- å¼•å…¥Three.js -->
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>

    <script>
        // ==================== ç²¾ç®€MPCæ¼”ç¤ºç³»ç»Ÿ ====================
        console.log("å¯åŠ¨MPCæ™ºèƒ½æ§åˆ¶ç³»ç»Ÿ...");
        
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let robot, base, arm, endEffector;
        let obstacles = [];
        let targetMaterial, platform;
        let mpcActive = false;
        let currentStep = 0;
        
        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            console.log("åˆå§‹åŒ–3Dåœºæ™¯...");
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f3460);
            scene.fog = new THREE.Fog(0x0f3460, 10, 50);
            
            // åˆ›å»ºç›¸æœº
            const container = document.getElementById('scene-container');
            camera = new THREE.PerspectiveCamera(
                65,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(15, 12, 18);
            camera.lookAt(0, 2, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å…‰
            setupLighting();
            
            // åˆ›å»ºç¯å¢ƒ
            createEnvironment();
            
            // åˆ›å»ºæœºå™¨äºº
            createRobot();
            
            // åˆ›å»ºéšœç¢ç‰©å’Œç‰©æ–™
            createObstaclesAndMaterials();
            
            // è®¾ç½®é¼ æ ‡æ§åˆ¶
            setupMouseControls();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            logMPC("ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
        }
        
        // è®¾ç½®ç¯å…‰
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(20, 30, 15);
            mainLight.castShadow = true;
            scene.add(mainLight);
        }
        
        // åˆ›å»ºç¯å¢ƒ
        function createEnvironment() {
            // åœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(40, 40);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a3a5f,
                shininess: 30
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // ç½‘æ ¼
            const gridHelper = new THREE.GridHelper(40, 40, 0x2a4d7a, 0x1a3a5f);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            
            // åæ ‡è½´
            const axesHelper = new THREE.AxesHelper(5);
            axesHelper.position.set(0, 0.1, 0);
            scene.add(axesHelper);
        }
        
        // åˆ›å»ºæœºå™¨äºº
        function createRobot() {
            robot = new THREE.Group();
            
            // åº•åº§
            const baseGeometry = new THREE.CylinderGeometry(1.2, 1.4, 0.8, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4a5568,
                shininess: 80
            });
            base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.4;
            base.castShadow = true;
            robot.add(base);
            
            // æœºæ¢°è‡‚ï¼ˆç®€åŒ–ä¸ºä¸€æ ¹æ‰‹è‡‚ï¼‰
            const armGeometry = new THREE.CylinderGeometry(0.3, 0.2, 4, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2d3748,
                shininess: 60
            });
            arm = new THREE.Mesh(armGeometry, armMaterial);
            arm.position.y = 2.5;
            base.add(arm);
            
            // æœ«ç«¯æ‰§è¡Œå™¨
            const endGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const endMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00b4d8,
                emissive: 0x003049,
                emissiveIntensity: 0.5
            });
            endEffector = new THREE.Mesh(endGeometry, endMaterial);
            endEffector.position.y = 2.0;
            arm.add(endEffector);
            
            // æ·»åŠ å¤¹å…·ç¤ºæ„
            const gripperGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.4);
            const gripperMaterial = new THREE.MeshPhongMaterial({ color: 0xe5383b });
            const gripper = new THREE.Mesh(gripperGeometry, gripperMaterial);
            gripper.position.y = -0.2;
            endEffector.add(gripper);
            
            scene.add(robot);
        }
        
        // åˆ›å»ºéšœç¢ç‰©å’Œç‰©æ–™
        function createObstaclesAndMaterials() {
            // åˆ›å»ºéšœç¢ç‰©ï¼ˆæ¨¡æ‹Ÿå¤å»ºç­‘ç¯å¢ƒï¼‰
            const obstaclePositions = [
                { x: 5, z: 0, r: 1.5, color: 0x8b7355, name: "çŸ³æŸ±" },
                { x: -3, z: 4, r: 1.2, color: 0xa68a64, name: "æ–‡ç‰©åº•åº§" },
                { x: 0, z: -5, r: 1.0, color: 0xc2b280, name: "ä¸´æ—¶æ”¯æ¶" },
                { x: -6, z: -2, r: 1.8, color: 0x7d6c4f, name: "å»ºç­‘æ„ä»¶" }
            ];
            
            obstacles = obstaclePositions.map(pos => {
                const geometry = new THREE.CylinderGeometry(pos.r, pos.r, 4, 16);
                const material = new THREE.MeshPhongMaterial({ 
                    color: pos.color,
                    transparent: true,
                    opacity: 0.7
                });
                const obstacle = new THREE.Mesh(geometry, material);
                obstacle.position.set(pos.x, 2, pos.z);
                obstacle.castShadow = true;
                scene.add(obstacle);
                
                return {
                    mesh: obstacle,
                    x: pos.x,
                    z: pos.z,
                    r: pos.r,
                    name: pos.name
                };
            });
            
            // åˆ›å»ºç›®æ ‡ç‰©æ–™
            const materialGeometry = new THREE.BoxGeometry(1.2, 0.8, 1.2);
            const materialMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xe5383b,
                emissive: 0x660708,
                emissiveIntensity: 0.3
            });
            targetMaterial = new THREE.Mesh(materialGeometry, materialMaterial);
            targetMaterial.position.set(6, 0.4, 6);
            targetMaterial.castShadow = true;
            scene.add(targetMaterial);
            
            // åˆ›å»ºæ”¾ç½®å¹³å°
            const platformGeometry = new THREE.BoxGeometry(6, 0.3, 4);
            const platformMaterial = new THREE.MeshPhongMaterial({ color: 0x2a9d8f });
            platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(-4, 0.15, -6);
            platform.receiveShadow = true;
            scene.add(platform);
        }
        
        // ==================== MPCæ ¸å¿ƒé€»è¾‘ ====================
        
        // æ‰§è¡ŒMPCä»»åŠ¡
        async function executeMPC(taskType) {
            if (mpcActive) {
                logMPC("MPCæ­£åœ¨è¿è¡Œä¸­ï¼Œè¯·ç­‰å¾…...");
                return;
            }
            
            mpcActive = true;
            
            // é‡ç½®æ­¥éª¤æŒ‡ç¤º
            resetSteps();
            
            try {
                switch(taskType) {
                    case 'path':
                        await runPathPlanning();
                        break;
                    case 'avoid':
                        await runObstacleAvoidance();
                        break;
                    case 'pickup':
                        await runPickupTask();
                        break;
                    case 'full':
                        await runFullWorkflow();
                        break;
                }
            } catch (error) {
                logMPC(`MPCæ‰§è¡Œå‡ºé”™: ${error.message}`);
            } finally {
                mpcActive = false;
            }
        }
        
        // è·¯å¾„è§„åˆ’æ¼”ç¤º
        async function runPathPlanning() {
            logMPC("å¼€å§‹æœ€ä¼˜è·¯å¾„è§„åˆ’...");
            
            const startTime = Date.now();
            const startPos = { x: robot.position.x, z: robot.position.z };
            const targetPos = { x: 8, z: 8 };
            
            // æ­¥éª¤1: å»ºç«‹æ¨¡å‹
            setActiveStep(1);
            logMPC("æ­¥éª¤1: å»ºç«‹æœºå™¨äººè¿åŠ¨æ¨¡å‹");
            await delay(800);
            
            // æ­¥éª¤2: é¢„æµ‹è½¨è¿¹
            setActiveStep(2);
            logMPC("æ­¥éª¤2: é¢„æµ‹æœªæ¥20æ­¥è½¨è¿¹");
            const predictedPath = predictPath(startPos, targetPos);
            visualizePrediction(predictedPath);
            await delay(1000);
            
            // æ­¥éª¤3: ä¼˜åŒ–æ±‚è§£
            setActiveStep(3);
            logMPC("æ­¥éª¤3: ä¼˜åŒ–è·¯å¾„å¹¶é¿å¼€éšœç¢ç‰©");
            const optimizedPath = optimizePath(predictedPath);
            visualizePrediction(optimizedPath, true);
            await delay(800);
            
            // æ­¥éª¤4-6: æ‰§è¡Œå¹¶å¾ªç¯
            for (let i = 0; i < 6; i++) {
                setActiveStep(4 + (i % 3));
                
                if (i < optimizedPath.length) {
                    const point = optimizedPath[i];
                    
                    // æ‰§è¡Œæ§åˆ¶
                    await moveRobotTo(point.x, point.z);
                    
                    // åé¦ˆæ›´æ–°
                    updateMetrics(startPos, point, i);
                    
                    // æ›´æ–°é¢„æµ‹è½¨è¿¹
                    if (i % 2 === 0) {
                        const newPrediction = predictPath(
                            { x: robot.position.x, z: robot.position.z },
                            targetPos
                        );
                        visualizePrediction(newPrediction);
                    }
                }
                
                await delay(500);
            }
            
            const computeTime = Date.now() - startTime;
            document.getElementById('computeTime').textContent = `${computeTime}ms`;
            logMPC(`è·¯å¾„è§„åˆ’å®Œæˆï¼Œç”¨æ—¶${computeTime}ms`);
        }
        
        // é¿éšœæ¼”ç¤º
        async function runObstacleAvoidance() {
            logMPC("å¼€å§‹æ™ºèƒ½é¿éšœæ¼”ç¤º...");
            
            // æ¨¡æ‹Ÿå¤æ‚ç¯å¢ƒ
            const startPos = { x: -8, z: -8 };
            const targetPos = { x: 8, z: 8 };
            
            await moveRobotTo(startPos.x, startPos.z);
            
            setActiveStep(1);
            logMPC("æ£€æµ‹åˆ°4ä¸ªéšœç¢ç‰©ï¼Œå¼€å§‹é¿éšœè§„åˆ’");
            
            // ç”Ÿæˆé¿éšœè·¯å¾„
            const avoidancePath = generateAvoidancePath(startPos, targetPos);
            visualizePrediction(avoidancePath, true);
            
            setActiveStep(2);
            logMPC("ä¼˜åŒ–é¿éšœè·¯å¾„ä¸­...");
            await delay(1000);
            
            setActiveStep(3);
            logMPC("å¼€å§‹æ‰§è¡Œé¿éšœè½¨è¿¹");
            
            // æ‰§è¡Œé¿éšœè·¯å¾„
            for (let i = 0; i < avoidancePath.length; i++) {
                const point = avoidancePath[i];
                await moveRobotTo(point.x, point.z);
                
                // è®¡ç®—ä¸æœ€è¿‘éšœç¢ç‰©çš„è·ç¦»
                const minDistance = calculateMinObstacleDistance(point);
                document.getElementById('obstacleDist').textContent = `${minDistance.toFixed(2)}m`;
                
                await delay(300);
            }
            
            logMPC("é¿éšœæ¼”ç¤ºå®Œæˆï¼ŒæˆåŠŸé¿å¼€æ‰€æœ‰éšœç¢ç‰©");
        }
        
        // æŠ“å–ä»»åŠ¡æ¼”ç¤º
        async function runPickupTask() {
            logMPC("å¼€å§‹è‡ªåŠ¨æŠ“å–ä»»åŠ¡è§„åˆ’...");
            
            // æ­¥éª¤1-2: è§„åˆ’åˆ°ç‰©æ–™è·¯å¾„
            setActiveStep(1);
            logMPC("è§„åˆ’åˆ°ç‰©æ–™çš„æŠ“å–è·¯å¾„");
            
            const toMaterialPath = predictPath(
                { x: robot.position.x, z: robot.position.z },
                { x: targetMaterial.position.x, z: targetMaterial.position.z }
            );
            
            visualizePrediction(toMaterialPath);
            await delay(800);
            
            // æ‰§è¡ŒæŠ“å–è·¯å¾„
            setActiveStep(3);
            for (const point of toMaterialPath.slice(0, 10)) {
                await moveRobotTo(point.x, point.z);
                await delay(300);
            }
            
            // æ¨¡æ‹ŸæŠ“å–åŠ¨ä½œ
            setActiveStep(4);
            logMPC("æ‰§è¡ŒæŠ“å–åŠ¨ä½œ...");
            await simulateGripperAction(true);
            
            // è§„åˆ’åˆ°å¹³å°è·¯å¾„
            setActiveStep(5);
            logMPC("è§„åˆ’åˆ°æ”¾ç½®å¹³å°çš„æ¬è¿è·¯å¾„");
            
            const toPlatformPath = predictPath(
                { x: robot.position.x, z: robot.position.z },
                { x: platform.position.x, z: platform.position.z }
            );
            
            visualizePrediction(toPlatformPath, true);
            
            // æ‰§è¡Œæ¬è¿è·¯å¾„
            setActiveStep(6);
            for (const point of toPlatformPath) {
                await moveRobotTo(point.x, point.z);
                await delay(300);
            }
            
            // æ¨¡æ‹Ÿé‡Šæ”¾åŠ¨ä½œ
            await simulateGripperAction(false);
            
            logMPC("è‡ªåŠ¨æŠ“å–ä»»åŠ¡å®Œæˆ");
        }
        
        // å®Œæ•´å·¥ä½œæµç¨‹
        async function runFullWorkflow() {
            logMPC("å¼€å§‹å®Œæ•´MPCå·¥ä½œæµç¨‹æ¼”ç¤º");
            
            // é‡ç½®æœºå™¨äººä½ç½®
            await moveRobotTo(-8, -8);
            
            // æ‰§è¡Œå„ä¸ªMPCä»»åŠ¡
            await runPathPlanning();
            await delay(1000);
            
            await runObstacleAvoidance();
            await delay(1000);
            
            await runPickupTask();
            
            logMPC("ğŸ‰ å®Œæ•´MPCå·¥ä½œæµç¨‹æ¼”ç¤ºå®Œæˆï¼");
        }
        
        // ==================== MPCå·¥å…·å‡½æ•° ====================
        
        // é¢„æµ‹è·¯å¾„ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        function predictPath(start, target, steps = 20) {
            const path = [];
            const dx = (target.x - start.x) / steps;
            const dz = (target.z - start.z) / steps;
            
            for (let i = 0; i <= steps; i++) {
                // æ·»åŠ ä¸€äº›éšæœºæ‰°åŠ¨æ¨¡æ‹Ÿä¸ç¡®å®šæ€§
                const noiseX = (Math.random() - 0.5) * 0.3;
                const noiseZ = (Math.random() - 0.5) * 0.3;
                
                path.push({
                    x: start.x + dx * i + noiseX,
                    z: start.z + dz * i + noiseZ,
                    step: i
                });
            }
            
            return path;
        }
        
        // ä¼˜åŒ–è·¯å¾„ï¼ˆç®€åŒ–é¿éšœé€»è¾‘ï¼‰
        function optimizePath(path) {
            return path.map((point, index) => {
                // æ£€æŸ¥æ˜¯å¦æ¥è¿‘éšœç¢ç‰©
                for (const obstacle of obstacles) {
                    const distance = Math.sqrt(
                        Math.pow(point.x - obstacle.x, 2) + 
                        Math.pow(point.z - obstacle.z, 2)
                    );
                    
                    // å¦‚æœå¤ªæ¥è¿‘éšœç¢ç‰©ï¼Œè°ƒæ•´è·¯å¾„
                    if (distance < obstacle.r + 1.5) {
                        // è®¡ç®—è¿œç¦»éšœç¢ç‰©çš„æ–¹å‘
                        const angle = Math.atan2(
                            point.z - obstacle.z,
                            point.x - obstacle.x
                        );
                        
                        return {
                            x: point.x + Math.cos(angle) * 0.5,
                            z: point.z + Math.sin(angle) * 0.5,
                            step: index
                        };
                    }
                }
                
                return point;
            });
        }
        
        // ç”Ÿæˆé¿éšœè·¯å¾„
        function generateAvoidancePath(start, target) {
            const path = [];
            const steps = 30;
            
            // ç”Ÿæˆç»•è¿‡éšœç¢ç‰©çš„è´å¡å°”æ›²çº¿
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                
                // è´å¡å°”æ›²çº¿æ§åˆ¶ç‚¹
                const p0 = start;
                const p1 = { x: -2, z: 0 };  // ç»•è¿‡å·¦ä¾§éšœç¢ç‰©
                const p2 = { x: 2, z: 0 };   // ç»•è¿‡å³ä¾§éšœç¢ç‰©
                const p3 = target;
                
                // ä¸‰æ¬¡è´å¡å°”æ›²çº¿
                const x = Math.pow(1-t, 3)*p0.x + 3*Math.pow(1-t, 2)*t*p1.x + 3*(1-t)*Math.pow(t, 2)*p2.x + Math.pow(t, 3)*p3.x;
                const z = Math.pow(1-t, 3)*p0.z + 3*Math.pow(1-t, 2)*t*p1.z + 3*(1-t)*Math.pow(t, 2)*p2.z + Math.pow(t, 3)*p3.z;
                
                path.push({ x, z, step: i });
            }
            
            return path;
        }
        
        // è®¡ç®—ä¸æœ€è¿‘éšœç¢ç‰©çš„è·ç¦»
        function calculateMinObstacleDistance(point) {
            let minDistance = Infinity;
            
            for (const obstacle of obstacles) {
                const distance = Math.sqrt(
                    Math.pow(point.x - obstacle.x, 2) + 
                    Math.pow(point.z - obstacle.z, 2)
                ) - obstacle.r;
                
                minDistance = Math.min(minDistance, distance);
            }
            
            return minDistance;
        }
        
        // ==================== å¯è§†åŒ–ä¸æ§åˆ¶ ====================
        
        // å¯è§†åŒ–é¢„æµ‹è½¨è¿¹
        function visualizePrediction(path, isOptimized = false) {
            const container = document.getElementById('predictionViz');
            container.innerHTML = '';
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            const scale = 6;
            
            // åˆ›å»ºSVGå®¹å™¨
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            
            // ç»˜åˆ¶é¢„æµ‹è½¨è¿¹
            let pathData = `M ${width/2} ${height/2}`;
            
            for (let i = 0; i < path.length; i++) {
                const x = width/2 + path[i].x * scale;
                const y = height/2 - path[i].z * scale;
                
                if (i === 0) {
                    pathData = `M ${x} ${y}`;
                } else {
                    pathData += ` L ${x} ${y}`;
                }
                
                // æ·»åŠ è·¯å¾„ç‚¹
                if (i % 5 === 0) {
                    const circle = document.createElementNS(svgNS, "circle");
                    circle.setAttribute("cx", x);
                    circle.setAttribute("cy", y);
                    circle.setAttribute("r", 2);
                    circle.setAttribute("fill", isOptimized ? "#2a9d8f" : "#00b4d8");
                    circle.setAttribute("opacity", "0.6");
                    svg.appendChild(circle);
                }
            }
            
            // ç»˜åˆ¶è·¯å¾„çº¿
            const pathElement = document.createElementNS(svgNS, "path");
            pathElement.setAttribute("d", pathData);
            pathElement.setAttribute("stroke", isOptimized ? "#2a9d8f" : "#00b4d8");
            pathElement.setAttribute("stroke-width", "2");
            pathElement.setAttribute("fill", "none");
            pathElement.setAttribute("opacity", "0.8");
            svg.appendChild(pathElement);
            
            container.appendChild(svg);
            
            // æ›´æ–°æ­¥é•¿æ˜¾ç¤º
            document.getElementById('horizonValue').textContent = `${path.length}æ­¥`;
            document.getElementById('iterationsValue').textContent = `${Math.floor(Math.random() * 50) + 20}æ¬¡`;
        }
        
        // ç§»åŠ¨æœºå™¨äººåˆ°æŒ‡å®šä½ç½®
        async function moveRobotTo(targetX, targetZ) {
            const currentX = robot.position.x;
            const currentZ = robot.position.z;
            
            const dx = targetX - currentX;
            const dz = targetZ - currentZ;
            const distance = Math.sqrt(dx * dx + dz * dz);
            const steps = Math.max(5, Math.floor(distance * 5));
            
            // å¹³æ»‘ç§»åŠ¨
            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const easeT = easeInOutCubic(t);
                
                robot.position.x = currentX + dx * easeT;
                robot.position.z = currentZ + dz * easeT;
                
                // ä½¿æœºå™¨äººé¢å‘ç§»åŠ¨æ–¹å‘
                if (Math.abs(dx) > 0.1 || Math.abs(dz) > 0.1) {
                    base.rotation.y = Math.atan2(dx, dz);
                }
                
                // æ ¹æ®ç§»åŠ¨è·ç¦»è°ƒæ•´æ‰‹è‡‚å§¿æ€
                const armAngle = Math.sin(t * Math.PI) * 0.3;
                arm.rotation.x = armAngle;
                
                await delay(50);
            }
        }
        
        // æ¨¡æ‹Ÿå¤¹å…·åŠ¨ä½œ
        async function simulateGripperAction(isGrab) {
            const gripper = endEffector.children[0];
            const targetScale = isGrab ? 1.5 : 1.0;
            const currentScale = gripper.scale.x;
            
            for (let i = 0; i <= 10; i++) {
                const t = i / 10;
                const scale = currentScale + (targetScale - currentScale) * t;
                
                gripper.scale.set(scale, 1, scale);
                await delay(50);
            }
            
            logMPC(isGrab ? "å¤¹å…·é—­åˆï¼ŒæŠ“å–ç‰©æ–™" : "å¤¹å…·å¼ å¼€ï¼Œé‡Šæ”¾ç‰©æ–™");
        }
        
        // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
        function updateMetrics(start, current, step) {
            const distance = Math.sqrt(
                Math.pow(current.x - start.x, 2) + 
                Math.pow(current.z - start.z, 2)
            );
            
            document.getElementById('pathLength').textContent = `${distance.toFixed(1)}m`;
            document.getElementById('energyCost').textContent = `${(step * 12.5).toFixed(0)}J`;
            document.getElementById('smoothness').textContent = `${Math.max(0, 100 - step * 2)}%`;
        }
        
        // ==================== UIæ§åˆ¶å‡½æ•° ====================
        
        // è®¾ç½®æ´»åŠ¨æ­¥éª¤
        function setActiveStep(stepNumber) {
            currentStep = stepNumber;
            
            // ç§»é™¤æ‰€æœ‰æ´»åŠ¨çš„æ­¥éª¤
            for (let i = 1; i <= 6; i++) {
                const stepElement = document.getElementById(`step${i}`);
                stepElement.classList.remove('active');
            }
            
            // æ¿€æ´»å½“å‰æ­¥éª¤
            const currentStepElement = document.getElementById(`step${stepNumber}`);
            if (currentStepElement) {
                currentStepElement.classList.add('active');
            }
        }
        
        // é‡ç½®æ­¥éª¤æŒ‡ç¤º
        function resetSteps() {
            for (let i = 1; i <= 6; i++) {
                const stepElement = document.getElementById(`step${i}`);
                stepElement.classList.remove('active');
            }
        }
        
        // æ·»åŠ MPCæ—¥å¿—
        function logMPC(message) {
            const logContainer = document.getElementById('mpcLog');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            const time = new Date().toLocaleTimeString();
            logEntry.innerHTML = `
                <span class="log-time">[${time}]</span>
                <span class="log-message"> ${message}</span>
            `;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            console.log(`MPC: ${message}`);
        }
        
        // ==================== å·¥å…·å‡½æ•° ====================
        
        // ç¼“åŠ¨å‡½æ•°
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // å»¶è¿Ÿå‡½æ•°
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // è®¾ç½®é¼ æ ‡æ§åˆ¶
        function setupMouseControls() {
            const canvas = renderer.domElement;
            let isDragging = false;
            let lastX = 0, lastY = 0;
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                
                // æ—‹è½¬è§†è§’
                const theta = deltaX * 0.01;
                const phi = deltaY * 0.01;
                
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                
                spherical.theta -= theta;
                spherical.phi = THREE.MathUtils.clamp(spherical.phi - phi, 0.1, Math.PI - 0.1);
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 2, 0);
                
                lastX = e.clientX;
                lastY = e.clientY;
            });
            
            canvas.addEventListener('wheel', (e) => {
                const delta = e.deltaY * 0.001;
                camera.position.multiplyScalar(1 + delta);
                e.preventDefault();
            });
            
            canvas.style.cursor = 'grab';
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            const container = document.getElementById('scene-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // åˆå§‹åŒ–ç³»ç»Ÿ
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>